import yaml from 'js-yaml';
import fs from 'node:fs/promises';
import path from 'node:path';

type OpenAPISchema = {
  type?: string;
  format?: string;
  properties?: Record<string, OpenAPISchema>;
  required?: string[];
  items?: OpenAPISchema;
  $ref?: string;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

type OpenAPIPathItem = {
  summary?: string;
  operationId?: string;
  parameters?: OpenAPIParameter[];
  requestBody?: OpenAPIRequestBody;
  responses?: OpenAPIResponses;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

type OpenAPIParameter = {
  name: string;
  in: 'query' | 'header' | 'path' | 'cookie';
  required?: boolean;
  schema?: OpenAPISchema;
  description?: string;
}

type OpenAPIRequestBody = {
  content: {
    [contentType: string]: {
      schema?: OpenAPISchema;
    };
  };
  required?: boolean;
}

type OpenAPIResponses = {
  [statusCode: string]: {
    description?: string;
    content?: {
      [contentType: string]: {
        schema?: OpenAPISchema;
      };
    };
  };
}

type OpenAPIComponents = {
  schemas?: Record<string, OpenAPISchema>;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

type OpenAPIDocument = {
  openapi: string;
  info: {
    title: string;
    version: string;
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    [key: string]: any;
  };
  paths: Record<string, Record<string, OpenAPIPathItem>>;
  components?: OpenAPIComponents;
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  [key: string]: any;
}

function getTypeNameFromRef(ref?: string): string | undefined {
  if (!ref) {
    return undefined;
  }
  if (ref.startsWith('#/components/schemas/')) {
    return ref.substring('#/components/schemas/'.length);
  }
  return undefined;
}

function mapOpenAPITypeToTypeScript(schema?: OpenAPISchema): string {
  if (!schema) {
    return 'any';
  }
  if (schema.$ref) {
    return getTypeNameFromRef(schema.$ref) || 'any';
  }
  switch (schema.type) {
    case 'string':
      return 'string';
    case 'integer':
    case 'number':
      return 'number';
    case 'boolean':
      return 'boolean';
    case 'array':
      if (schema.items) {
        return `${mapOpenAPITypeToTypeScript(schema.items)}[]`;
      }
      return 'any[]';
    case 'object':
      if (schema.properties) {
        const props = Object.entries(schema.properties)
          .map(([key, propSchema]) => {
            const isRequired = schema.required?.includes(key);
            return `${key}${isRequired ? '' : '?'}: ${mapOpenAPITypeToTypeScript(propSchema)};`;
          })
          .join('\n  ');
        return `{\n  ${props}\n}`;
      }
      return 'Record<string, any>';
    default:
      return 'any';
  }
}

function createStrFromDocument(doc: OpenAPIDocument) {
  const header = `// Generated by CLI\n\n`
  let scriptOutput = header;
  let typeOutput = header;

  // Type Definitions
  if (doc.components?.schemas) {
    for (const [name, schema] of Object.entries(doc.components.schemas)) {
      typeOutput += `export type ${name} = ${mapOpenAPITypeToTypeScript(schema)} \n\n`;
    }
  }

  // Path Information
  if (doc.paths) {
    scriptOutput += 'export const paths = {\n';
    typeOutput += 'export type Paths = {\n';
    for (const [pathKey, pathItem] of Object.entries(doc.paths)) {
      scriptOutput += `  '${pathKey}': {\n`;
      typeOutput += `  '${pathKey}': {\n`;
      for (const [method, operation] of Object.entries(pathItem)) {
        scriptOutput += `    ${method.toUpperCase()}: {\n`;
        typeOutput += `    ${method.toUpperCase()}: {\n`;
        let getPathFunc = `      getPath: () => { return '${pathKey}' as const; }\n`;
        if (operation.parameters && operation.parameters.length > 0) {
          const createTypeParamStr = (param: OpenAPIParameter) => {
            return `        ${param.name}${param.required ? '' : '?'}: ${mapOpenAPITypeToTypeScript(param.schema)};`;
          }
          typeOutput += `      parameters: {\n`;
          const keys: OpenAPIParameter['in'][] = ['query', 'header', 'path', 'cookie'];
          for (const key of keys) {
            const list = operation.parameters.filter((e) => e.in === key);
            if (list.length > 0) {
              if (key === 'path') {
                const args = list.map((e) => `${e.name}${e.required ? '' : '?'}: ${mapOpenAPITypeToTypeScript(e.schema)}`).join('; ')
                const returnPath = list.reduce((prev, e) => {
                  return pathKey.replace(`{${e.name}}`, `\${options.${e.name}}`);
                }, '');
                getPathFunc = `      getPath: (options: { ${args} }) => { return \`${returnPath}\` as const; }\n`;
              }
              typeOutput += list.map((e) => createTypeParamStr(e)).join('\n') + '\n';
            }
          }
          typeOutput += `      }\n`;
        } else {
          typeOutput += `      parameters: {}\n`;
        }
        scriptOutput += getPathFunc;

        // requestBody
        let requestBodyStr = `      requestBody: void;\n`;
        if (operation.requestBody?.content) {
          const requestBodySchema = Object.values(operation.requestBody.content)[0]?.schema;
          if (requestBodySchema) {
            requestBodyStr = `      requestBody: ${mapOpenAPITypeToTypeScript(requestBodySchema)};\n`;
          }
        }
        typeOutput += requestBodyStr;
        
        if (operation.responses) {
          typeOutput += `      responses: {\n`;
          for (const [statusCode, response] of Object.entries(operation.responses)) {
            const responseSchema = Object.values(response.content || {})[0]?.schema;
            if (responseSchema) {
                typeOutput += `        ${statusCode}: ${mapOpenAPITypeToTypeScript(responseSchema)};\n`;
            } else {
                typeOutput += `        ${statusCode}: void;\n`;
            }
          }
          typeOutput += `      }\n`;
        }
        scriptOutput += `    },\n`;
        typeOutput += `    }\n`;
      }
      scriptOutput += '  },\n';
      typeOutput += '  }\n';
    }
    scriptOutput += '} as const\n';
    typeOutput += '}\n';
  }

  return { scriptOutput, typeOutput };
}

async function main() {
  const filePath = path.resolve(import.meta.dirname, '../tsp-output/schema/openapi.yaml');
  const doc = yaml.load(await fs.readFile(filePath, 'utf8')) as OpenAPIDocument;

  const { scriptOutput, typeOutput } = createStrFromDocument(doc);

  const targetDir = path.resolve(import.meta.dirname, '../dist');
  await fs.mkdir(targetDir, { recursive: true });
  await Promise.all([
    fs.writeFile(path.resolve(targetDir, 'type.ts'), typeOutput, 'utf8'),
    fs.writeFile(path.resolve(targetDir, 'constants.ts'), scriptOutput, 'utf8')
  ])
}
main().catch(console.error);
